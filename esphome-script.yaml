esphome:
  name: esp32_noise_sensor
  friendly_name: ESP Noise meter 001
  comment: "KE-ZS-BZ-TTL-05 noise sensor with OLED display"
  # ---------------- Timed OLED power save ----------------
  on_boot:
    priority: 600
    then:
      # Start a 3-minute timer to turn off OLED
      - delay: 180s
      - logger.log: "OLED timeout reached, turning off"
      - lambda: |-
          id(oled).turn_off();


esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  framework:
    type: arduino
  flash_size: 4MB


# ---------------- WIFI & MQTT ----------------
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  power_save_mode: none
  fast_connect: true
  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Esp-Noise-Meter-001"
    password: !secret ap_password

mqtt:
  broker: !secret mqtt_host
  # username: !secret mqtt_user
  # password: !secret mqtt_pass

logger:
  baud_rate: 115200
  level: DEBUG

interval:
  - interval: 2s
    then:
      - lambda: |-
          static const uint8_t CMD_READ_NOISE[8] = {0x01,0x03,0x00,0x00,0x00,0x01,0x84,0x0A};
          uint8_t response[16];
          id(noise_uart).write_array(CMD_READ_NOISE, 8);
          delay(20);

          int count = 0;
          while (id(noise_uart).available() && count < sizeof(response)) {
            uint8_t byte;
            if (id(noise_uart).read_byte(&byte)) {
              response[count++] = byte;
            }
          }

          if (count >= 7 && response[0]==0x01 && response[1]==0x03 && response[2]==0x02) {
            uint16_t val = (response[3] << 8) | response[4];
            float db = val / 10.0f;
            id(noise_level).publish_state(db);
            ESP_LOGI("noise", "Noise: %.1f dB", db);
          } else {
            ESP_LOGW("noise", "Invalid or incomplete response (count=%d)", count);
          }

uart:
  id: noise_uart
  tx_pin: 46
  rx_pin: 42
  baud_rate: 9600
  data_bits: 8
  stop_bits: 1
  parity: NONE

sensor:
  - platform: template
    id: noise_level
    name: "Noise Level"
    unit_of_measurement: "dB"
    accuracy_decimals: 1
    update_interval: never

  # --- Wi-Fi RSSI
  - platform: wifi_signal
    name: "WiFi RSSI"
    id: wifi_rssi
    update_interval: 10s
    entity_category: "diagnostic"
    
  - platform: template
    name: "WiFi TX Power"
    id: wifi_tx_power
    unit_of_measurement: "dBm"
    entity_category: "diagnostic"
    update_interval: 10s
    lambda: |-
      // Get current TX power in dBm
      float power = WiFi.getTxPower();
      return power;

  - platform: copy # Reports the WiFi signal strength in %
    source_id: wifi_rssi
    name: "Signal %"
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: " %"
    entity_category: "diagnostic"
    device_class: ""
  - platform: uptime
    name: Uptime
    disabled_by_default: false
    force_update: false
    unit_of_measurement: s
    icon: mdi:timer-outline
    accuracy_decimals: 0
    device_class: duration
    state_class: total_increasing
    entity_category: diagnostic
    update_interval: 60s
  - platform: internal_temperature
    name: "Internal Temperature"
    update_interval: 60s
    entity_category: diagnostic
    disabled_by_default: false
    unit_of_measurement: Â°C
    state_class: measurement
    device_class: temperature
  - platform: adc
    pin: GPIO5 # Need to find the right pin for actual voltage
    name: "Voltage"
    update_interval: 60s
    entity_category: diagnostic
    attenuation: 11db

text_sensor:
  - platform: wifi_info
    ip_address:
      name:  IP
      update_interval: 60s
    ssid:
      name:  SSID

button:
  - platform: restart
    name: Restart
    entity_category: diagnostic
    disabled_by_default: false
    icon: mdi:restart
    device_class: restart

# ---------------- OLED DISPLAY ----------------
i2c:
  sda: GPIO18
  scl: GPIO17
  scan: true

font:
  - file: 
      type: gfonts
      family: Roboto
      weight: 700
    id: font_large
    size: 27
  - file:  "gfonts://Roboto"
    id: font_small
    size: 12

display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    id: oled
    address: 0x3C
    rotation: 0
    lambda: |-
      if (id(noise_level).has_state()) {
        it.printf(0, 10, id(font_large), "%.1f dB", id(noise_level).state);
      } else {
        it.printf(0, 10, id(font_large), "--- dB");
      }
      it.printf(0, 50, id(font_small), "WiFi RSSI: %.0f dBm", id(wifi_rssi).state);


# helper to track time
time:
  - platform: sntp
    id: sntp_time

# ---------------- Internal helpers ----------------
globals:
  - id: display_timer_start
    type: unsigned long
    restore_value: no
    initial_value: '0'

script:
  - id: display_timeout
    mode: restart
    then:
      - lambda: |-
          id(display_timer_start) = millis();
      - delay: 180s
      - logger.log: "OLED timeout reached, turning off"
      - lambda: |-
          id(oled).turn_off();



# Enable Home Assistant API
api:
  encryption:
    key: !secret encryption_key

ota:
  - platform: esphome
    password: !secret ota_password


captive_portal: